use std::str::FromStr;
use crate::ast::{ExprTree, BinOp, LogOp, BoolType, Type, FnHead};

grammar;

pub SeparateFn: Box<ExprTree> = {
    "fn" <StatementFn> "}" => <>,
}

pub SeparateLines: Box<ExprTree> = {
    <FindKeyword> ";" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),
    <FindKeyword> "}" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),

    <FindKeyword> ";",
    <FindKeyword> "}",
     
}

pub FindKeyword: Box<ExprTree> = {
    "let" <Assign>,
    "if" <StatementIf>,
    "while" <StatementWhile>,

    "pass" => Box::new(ExprTree::Pass), 
}


StatementFn: Box<ExprTree> = {
    <FnHead> "(" <Params> ") -> " <FnType> "{" <SeparateLines> => Box::new(ExprTree::FnNode(<>)),
}

FnHead: FnHead = {
    Var => FnHead::Name(<>),
}

pub Params: FnHead = {
    <CommaSepVec> => FnHead::Params(<>),
}

pub CommaSepVec = Comma<AssignParam>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

StatementWhile: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> => Box::new(ExprTree::WhileNode(<>)),
}

StatementIf: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),

    "(" <NumComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),
}

AssignParam: Box<ExprTree> = {
    AssignVar VarType => Box::new(ExprTree::ParamNode(<>)),
}

pub Assign: Box<ExprTree> = {
    AssignVar VarType Expr => Box::new(ExprTree::AssignNode(<>)),
    AssignVar VarType BoolComp => Box::new(ExprTree::AssignNode(<>)),
    AssignVar VarType NumComp => Box::new(ExprTree::AssignNode(<>)),
}

AssignVar: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
}

FnType: FnHead = {
    "i32" => FnHead::Return(Type::I32),
    "bool" => FnHead::Return(Type::Bool),
}

VarType: Type ={
    ": i32" "="? => Type::I32,
    ": bool" "="? => Type::Bool,
}

pub BoolComp: Box<ExprTree> = {
    BoolComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),
    NumComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),

    NumComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),
    BoolComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),

    BoolType
}

BoolType: Box<ExprTree> = {
    "true" => Box::new(ExprTree::Bool(BoolType::True)),
    "false" => Box::new(ExprTree::Bool(BoolType::False)),
}

BoolOp: LogOp = {
    "&&" => LogOp::And,
    "||" => LogOp::Or,
}

pub NumComp: Box<ExprTree> = {
    Expr NumCompOp Expr => Box::new(ExprTree::LogNode(<>)),
}

NumCompOp: LogOp = {
    "<" => LogOp::Les,
    ">" => LogOp::Gre,
    "<=" => LogOp::LeEq,
    ">=" => LogOp::GrEq,
    "==" => LogOp::Eq,
    "!=" => LogOp::NoEq,
}



pub Expr: Box<ExprTree> = { 
    Expr ExprOp Factor => Box::new(ExprTree::BinNode(<>)),
    Factor,
};

ExprOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};


Factor: Box<ExprTree> = {
    Factor FactorOp Term => Box::new(ExprTree::BinNode(<>)),
    Term,
};

FactorOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

Term: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
    Num => Box::new(ExprTree::Number(<>)),
    "(" <Expr> ")",
};

Num: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap()
};

Var: String = {
    r"[A-z_][A-z0-9_]*" => String::from(<>)
}