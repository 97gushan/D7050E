use std::str::FromStr;
use crate::ast::{ExprTree, BinOp, LogOp, NumCompOp, BoolType, Type, FnHead};

grammar;

pub Program: Vec<Box<ExprTree>> = {
    <FunSepVec> => <>,
}

SeparateFn: Box<ExprTree> = {
    "fn" <StatementFn>  => <>,
}

pub SeparateLines: Box<ExprTree> = {
    <FindKeyword> ";" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),
    <FindKeyword> "}" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),

    <FindKeyword> ";",
    <FindKeyword> "}",
     
}

FindKeyword: Box<ExprTree> = {
    "let" <Assign>,
    "if" <StatementIf>,
    "while" <StatementWhile>,

    "pass" => Box::new(ExprTree::Pass), 

    <v:Var> "=" <e:Expr> => Box::new(ExprTree::SetVarNode(Box::new(ExprTree::Var(v)), e)),
        
    <FunctionCall>,

    "return" <Expr> => Box::new(ExprTree::Return(<>)), 

}

FunctionCall: Box<ExprTree> = {
    <FnHead> "(" <Arguments> ")" => Box::new(ExprTree::FunctionCall(<>)),
}

StatementFn: Box<ExprTree> = {
    <FnHead> "(" <Params> ") -> " <FnType> "{" <SeparateLines> => Box::new(ExprTree::FnNode(<>)),
}

FnHead: FnHead = {
    Var => FnHead::Name(<>),
}

FunSepVec = FunSep<SeparateFn>;

FunSep<T>: Vec<T> = {
    <v:(<T> "}")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Arguments: FnHead = {

    Comma<Expr> => FnHead::Params(<>),
}

Params: FnHead = {
    <CommaSepVec> => FnHead::Params(<>),
}

CommaSepVec = Comma<AssignParam>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

StatementWhile: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> => Box::new(ExprTree::WhileNode(<>)),
}

StatementIf: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),

    "(" <NumComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),

    "(" <Expr> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <Expr> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <Expr> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),
}

AssignParam: Box<ExprTree> = {
    AssignVar VarType => Box::new(ExprTree::ParamNode(<>)),
}

Assign: Box<ExprTree> = {
    AssignVar VarType Expr => Box::new(ExprTree::AssignNode(<>)),
    AssignVar VarType BoolComp => Box::new(ExprTree::AssignNode(<>)),
    AssignVar VarType NumComp => Box::new(ExprTree::AssignNode(<>)),
}

AssignVar: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
}

FnType: FnHead = {
    "i32" => FnHead::Return(Type::I32),
    "bool" => FnHead::Return(Type::Bool),
}

VarType: Type ={
    ": i32" "="? => Type::I32,
    ": bool" "="? => Type::Bool,
}

pub BoolComp: Box<ExprTree> = {
    BoolComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),
    BoolComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),

    NumComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),
    NumComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),

    BoolComp BoolOp Expr => Box::new(ExprTree::LogNode(<>)),
    Expr BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),
    Expr BoolOp Expr => Box::new(ExprTree::LogNode(<>)),

    Expr BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),
    NumComp BoolOp Expr => Box::new(ExprTree::LogNode(<>)),

    BoolType,
    
}

BoolType: Box<ExprTree> = {
    "true" => Box::new(ExprTree::Bool(BoolType::True)),
    "false" => Box::new(ExprTree::Bool(BoolType::False)),
}

BoolOp: LogOp = {
    "&&" => LogOp::And,
    "||" => LogOp::Or,
}

pub NumComp: Box<ExprTree> = {
    Expr NumCompOp Expr => Box::new(ExprTree::NumCompNode(<>)),
    Expr NumCompOp BoolType => Box::new(ExprTree::NumCompNode(<>)),
    BoolType NumCompOp Expr => Box::new(ExprTree::NumCompNode(<>)),
    BoolType NumCompOp BoolType => Box::new(ExprTree::NumCompNode(<>)),
}

NumCompOp: NumCompOp = {
    "<" => NumCompOp::Les,
    ">" => NumCompOp::Gre,
    "<=" => NumCompOp::LeEq,
    ">=" => NumCompOp::GrEq,
    "==" => NumCompOp::Eq,
    "!=" => NumCompOp::Neq,
}



pub Expr: Box<ExprTree> = { 
    Expr ExprOp Factor => Box::new(ExprTree::BinNode(<>)),
    Factor, 
};

ExprOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};


Factor: Box<ExprTree> = {
    Factor FactorOp Term => Box::new(ExprTree::BinNode(<>)),
    Term,
};

FactorOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

Term: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
    Num => Box::new(ExprTree::Number(<>)),
    <FunctionCall>,
    "(" <Expr> ")",
};

Num: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap()
};

Var: String = {
    r"[A-z_][A-z0-9_]*" => String::from(<>)
}