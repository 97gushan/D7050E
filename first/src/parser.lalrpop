use std::str::FromStr;
use crate::ast::{ExprTree, BinOp, LogOp, BoolType, Type};

grammar;

pub SeparateLines: Box<ExprTree> = {
    <FindKeyword> ";" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),
    <FindKeyword> "}" <SeparateLines> => Box::new(ExprTree::SeqNode(<>)),

    <FindKeyword> ";",
    <FindKeyword> "}",
     
}

pub FindKeyword: Box<ExprTree> = {
    "let" <Assign>,
    "if" <StatementIf>,
    "while" <StatementWhile>,
    Assign,  // assignment on already created var 
}


StatementWhile: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> => Box::new(ExprTree::WhileNode(<>)),
}

StatementIf: Box<ExprTree> = {
    "(" <BoolComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <BoolComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),

    "(" <NumComp> ")" "{" <SeparateLines> "}else if" <StatementIf> => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines> "}else{" <SeparateLines>  => Box::new(ExprTree::IfElseNode(<>)),
    "(" <NumComp> ")" "{" <SeparateLines>  => Box::new(ExprTree::IfNode(<>)),
}

pub Assign: Box<ExprTree> = {
    AssignVar Type Expr => Box::new(ExprTree::AssignNode(<>)),
    AssignVar Type BoolComp => Box::new(ExprTree::AssignNode(<>)),
    AssignVar Type NumComp => Box::new(ExprTree::AssignNode(<>)),
}

AssignVar: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
}

Type: Type ={
    ": i32 =" => Type::I32,
    ": bool =" => Type::Bool,
}

pub BoolComp: Box<ExprTree> = {
    BoolComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),
    NumComp BoolOp NumComp => Box::new(ExprTree::LogNode(<>)),

    NumComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),
    BoolComp BoolOp BoolType => Box::new(ExprTree::LogNode(<>)),

    BoolType
}

BoolType: Box<ExprTree> = {
    "true" => Box::new(ExprTree::Bool(BoolType::True)),
    "false" => Box::new(ExprTree::Bool(BoolType::False)),
}

BoolOp: LogOp = {
    "&&" => LogOp::And,
    "||" => LogOp::Or,
}

pub NumComp: Box<ExprTree> = {
    Expr NumCompOp Expr => Box::new(ExprTree::LogNode(<>)),
}

NumCompOp: LogOp = {
    "<" => LogOp::Les,
    ">" => LogOp::Gre,
    "<=" => LogOp::LeEq,
    ">=" => LogOp::GrEq,
    "==" => LogOp::Eq,
    "!=" => LogOp::NoEq,
}



pub Expr: Box<ExprTree> = { 
    Expr ExprOp Factor => Box::new(ExprTree::BinNode(<>)),
    Factor,
};

ExprOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};


Factor: Box<ExprTree> = {
    Factor FactorOp Term => Box::new(ExprTree::BinNode(<>)),
    Term,
};

FactorOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

Term: Box<ExprTree> = {
    Var => Box::new(ExprTree::Var(<>)),
    Num => Box::new(ExprTree::Number(<>)),
    "(" <Expr> ")",
};

Num: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap()
};

Var: String = {
    r"[A-z_][A-z0-9_]*" => String::from(<>)
}